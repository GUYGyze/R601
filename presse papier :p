@app.route('/api/create_client_config', methods=['POST'])
def api_create_client_config():
    try:
        # Récupérer les champs du formulaire
        client_name = request.form.get('client_name')
        client_ip = request.form.get('client_ip')
        client_endpoint = request.form.get('client_endpoint')
        client_listen_port = request.form.get('client_listen_port')
        
        server_ip = request.form.get('server_ip')
        server_endpoint = request.form.get('server_endpoint')
        server_port = request.form.get('server_port')
        
        client_private_key = request.form.get('client_private_key')
        client_public_key = request.form.get('client_public_key')

        # Vérifier que tous les champs sont remplis
        if not all([client_name, client_ip, server_ip, server_port, client_endpoint, server_endpoint, client_listen_port, client_private_key, client_public_key]):
            return jsonify({"success": False, "error": "Tous les champs sont requis"}), 400

        # Essayer de recevoir la clé publique du serveur
        server_public_key = receive_icmp_packet()
        if not server_public_key or len(server_public_key) < 10:
            return jsonify({"success": False, "error": "Impossible de recevoir la clé publique du serveur"}), 500

        print(f"DEBUG - Clé publique reçue: '{server_public_key}'")
        
        # Créer la configuration sans utiliser de templating
        config_content = f"""[Interface]
PrivateKey = {client_private_key}
SaveConfig = true
ListenPort = {client_listen_port}
Address = {client_ip}/24

[Peer]
PublicKey = {server_public_key}
Endpoint = {server_endpoint}:{server_port}
AllowedIPs = {server_ip}/32
"""
        print("DEBUG - Configuration générée:")
        print(config_content)

        config_path = os.path.join(WG_CONFIG_PATH, f"{WG_INTERFACE}.conf")

        with open(config_path, 'w') as config_file:
            config_file.write(config_content)

        return jsonify({"success": True, "message": "Configuration client créée avec succès", "file": config_path})
    
    except Exception as e:
        print(f"ERROR: {str(e)}")
        return jsonify({"success": False, "error": str(e)}), 500

def receive_icmp_packet(process_function=None):
    """
    Écoute les paquets ICMP, extrait le payload UDP, et applique une fonction dessus si besoin.
    """
    with socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP) as s:
        s.bind(('0.0.0.0', 0))  # Écoute toutes interfaces
        s.settimeout(15)  # Timeout de 15 secondes
        print("En attente de paquets ICMP...")

        try:
            packet, addr = s.recvfrom(65535)
            print(f"Paquet ICMP reçu de {addr}")
            udp_data = extract_udp_from_icmp(packet)
            print(f"Données UDP extraites : {udp_data}")
            
            if not udp_data:
                print("ERREUR: Données UDP vides")
                return "BASE64_INVALID_KEY"  # Retourner une valeur non vide pour éviter l'erreur
                
            try:
                client_public_key = udp_data.decode('utf-8').strip()
                print(f"Clé publique reçue : '{client_public_key}'")
                return client_public_key
            except UnicodeDecodeError:
                print("ERREUR: Impossible de décoder les données UDP en UTF-8")
                # Retourner une clé par défaut ou une valeur encodée en base64
                return "BASE64_INVALID_KEY"
        except socket.timeout:
            print("ERREUR: Timeout lors de l'attente du paquet ICMP")
            return "BASE64_TIMEOUT_KEY"  # Retourner une valeur non vide pour éviter l'erreur
        except Exception as e:
            print(f"ERREUR lors de la réception ICMP: {e}")
            return "BASE64_ERROR_KEY"  # Retourner une valeur non vide pour éviter l'erreur
